#include<iostream>//ac
#include<cmath>
#include<algorithm>
using namespace std;

//题解：线性dp，分类讨论
//对于每个行来说，遍历完所有线段后可以有两种情况，最后处于左端点或右端点
//那么可以有 f[i][0]:走完i及i以前的线段后处于左端点所需要走的最短路程
//           f[i][1]:走完i及i以前的线段后处于右端点所需要走的最短路程
//转移过程：
//由于需要减少路程，所以处于一个端点肯定是由当前另外一个端点走过来的！！！
//f[i][0]: min（由上一个右端点走到当前左端点，由上一个左端点走到当前左端点）
//上一个右端点 -> 当前右端点 -> 当前左端点；上一个左端点 -> 当前右端点 -> 当前左端点
//f[i][1]：min（由上一个左端点走到当前右端点，由上一个右端点走到当前右端点）
//上一个左端点 -> 当前左端点 -> 当前右端点；上一个右端点 -> 当前左端点 -> 当前右端点

const int MAXN = 2e4+5;
int l[MAXN],r[MAXN];
int f[MAXN][2];//0左，1右
int Len(int i) {//计算遍历i行线段需要的路程
    return r[i]-l[i];
}
int main() {
    int n;
    cin>>n;
    for(int i = 1;i <= n;i++) {
        cin>>l[i]>>r[i];
    }
    f[1][0] = r[1] + Len(1) - 1;//初始边界，注意起点坐标为 (1,1)
    f[1][1] = r[1] - 1;         //直接走到右端点
    for(int i = 2;i <= n;i++) {
        //上一个右端点到当前左端点
        f[i][0] = f[i-1][1] + abs(r[i-1]-r[i]) + 1 + Len(i);
        //上一个左端点到当前左端点
        f[i][0] = min(f[i][0], f[i-1][0] + abs(l[i-1]-r[i]) + 1 + Len(i));
        //上一个左端点到当前右端点
        f[i][1] = f[i-1][0] + abs(l[i-1]-l[i]) + 1 + Len(i);
        //上一个右端点到当前右端点
        f[i][1] = min(f[i][1], f[i-1][1] + abs(r[i-1]-l[i]) + 1 + Len(i));
    }
    //最后一行还需要添加到达终点的距离！！！
    cout<<min(f[n][0]+(n-l[n]), f[n][1]+(n-r[n]));
    return 0;
}
